#+AUTHOR: hathawayANdRX105
#+EMAIL: 2635254302@qq.com
#+STARTUP: indent
#+OPTIONS: \n: t
#+OPTIONS: ^:nil

* 原码、反码、补码
计算机中将数用二进制表示，常理解的形式都为原码，通常为0正1负
如(假设最大位数为8)：5的原码 0000 0101, -5的原码为 1000 0101


用于表示有符号的二进制数，通常最大位是符号位，而无符号二进制数都是整数


正数的原码、反码、补码都相同
负数的原码在符号位不同，其余相同，反码则符号位不变，其余取反，补码则是反码在最小位处加1
注：计算机系统中，正数都为原码表示，但负数用补码表示

#+begin_src
  按照原码的思路来说，占用了最大位的符号位，不能表示更大的进制数
  那么正数的表示范围是 1~127， 而负数同样是 -127 ~ -1
  这里用原码表示：[0000 0001 ~ 0111 1111], [1000 0001 ~ 1111 1111]

  对于0来说有两种形式表示，+0，与-0
  0000 0000 跟 1000 0000
  为了不浪费多出0的表示形式，-0代表着 -128，并且负数以补码形式表示

  正数
  0000 0001 -> 1
  0111 1111 -> 127 = 2^8 - 1 = 2^7 + 2^6 +...+ 2^0

  负数
  1111 1111 -> -1
  1000 0000 -> -128
  1000 0001 -> -127 = -(2^8 - 1) = -2^8 + 2^1
  1111 1011 -> -5 = -2^8 + 2^7 + 2^6 +...+ 2^0 - 2^2 = -128 + 127 - 4

#+end_src

* 位运算
- & ：按位与，同为1则为1，否则为0
- | ：按位或，只有同为0则为0，否则为1
- ^ ：按位异或，同位相同则为0，相异则为1
- ~ ：按位取反，位为0则为1，位为1则为0

* 位移
<< ：左移，低位补0
>> ：右移，有符号情况下，负数高位补1，正数高位补0


* 由位运算实现加减乘除四则运算
** 加法
分析正负数的原码、补码进行加法
#+begin_src
  // 假设最大位数为8
  3+7 = 10
  0000 0011 -> 3
  0000 0111 -> 7
  
  同位都为1，则需要进位，并且需要将该位置0

  -----------------------------------------
  round 1:
  
  0000 0100 -> 4  无进位数  3^7
  0000 0011 -> 3  需要进位数  3&7
  0000 0110 -> 6  进位数  (3&7)<<1

  -----------------------------------------
  round 2:
  
  0000 0010 -> 2  无进位数  4^6
  0000 0100 -> 4  需要进位数  4&6
  0000 1000 -> 8  (4&6)<<1
  
  -----------------------------------------
  round 3:

  0000 1010 -> 10 无进位数
  0000 0000 -> 0  需要进位数
#+end_src




** 求相反数
对原码取反后需要加1
#+begin_src

 假设最大位数为8
 假设要对3 求相反数
 0000 0011 -> 3    3的原码
 1111 1100 -> -4   3的取反
 1111 1101 -> -3   -3的补码

 假设要对-3 求相反数
 1111 1101 -> -3   -3的补码
 0000 0010 -> 2    -3的取反
 0000 0011 -> 3    3的原码
  
#+end_src


** 减法
根据交换律可知 a - b = a + (-b)

** 乘法
假设求 3x7 = 21
原理: 7个3 相加
快速的倍数相加，能拆分成 7[0000 0111]， 1 + 2 + 4 个 3相加
3 + 3 * 2 + 3 * 2 * 2 = 21

** 除法
原理与乘法相同
假设最大位数为8
b / a = c
猜测比a刚好大的最大右移shift，即 b>>shift >= a
说明 b中包含了 a << shift 或 a * (1 << shift) ，或 a * 2^shift
加上2^shift 的倍数， b减去组成当前最大倍数a的数，继续右移寻找可能的2^shift 的倍数。
